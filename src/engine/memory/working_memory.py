from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime

from ..models.entry import Entry
from ..models.emotional_state import EmotionalState


@dataclass
class StructuredInput:
    """
    Rich, structured representation of user input after perceptual analysis.
    """
    raw_text: str
    language: str
    entities: List[tuple]  # (entity_text, entity_type)
    intent: str  # e.g., 'QUESTION', 'CHALLENGE_PROPOSAL', 'REFLECTION'
    sentiment: str  # e.g., 'POSITIVE', 'NEGATIVE', 'NEUTRAL', 'CURIOUS'
    tone: str  # e.g., 'FORMAL', 'CASUAL', 'SKEPTICAL', 'ENTHUSIASTIC'
    confidence: float = 0.0  # Confidence in the analysis
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class CognitiveState:
    """
    Represents the current state of the cognitive process.
    """
    cycle_count: int = 0
    is_stable: bool = False
    confidence_score: float = 0.0
    last_update: datetime = field(default_factory=datetime.now)
    active_insights: List[str] = field(default_factory=list)
    detected_paradoxes: List[str] = field(default_factory=list)
    
    # Emotional processing state
    emotional_state: Optional[EmotionalState] = None
    emotional_processing_enabled: bool = False


class WorkingMemory:
    """
    The central "blackboard" for the current thinking process.
    Acts as a shared workspace where all cognitive processors can read and write.
    """
    
    def __init__(self):
        self.structured_input: Optional[StructuredInput] = None
        self.retrieved_memories: List[Entry] = []
        self.generated_insights: List[Entry] = []
        self.cognitive_state: CognitiveState = CognitiveState()
        self.associations: List[Dict[str, Any]] = []
        self.context_tags: List[str] = []
        self.context_data: Dict[str, Any] = {}  # For storing processor-specific context
        
        print("WorkingMemory initialized - cognitive workspace ready.")
    
    def clear(self):
        """Reset the working memory for a new cognitive cycle."""
        self.structured_input = None
        self.retrieved_memories.clear()
        self.generated_insights.clear()
        self.associations.clear()
        self.context_tags.clear()
        self.context_data.clear()
        self.cognitive_state = CognitiveState()
        print("WorkingMemory cleared.")
    
    def set_input(self, structured_input: StructuredInput):
        """Set the current structured input."""
        self.structured_input = structured_input
        self.cognitive_state.last_update = datetime.now()
        print(f"WorkingMemory: New input set - Intent: {structured_input.intent}, Sentiment: {structured_input.sentiment}")
    
    def add_retrieved_memories(self, memories: List[Entry]):
        """Add memories retrieved from long-term memory."""
        self.retrieved_memories.extend(memories)
        self.cognitive_state.last_update = datetime.now()
        print(f"WorkingMemory: Added {len(memories)} retrieved memories")
    
    def add_associations(self, associations: List[Dict[str, Any]]):
        """Add associations found by the associative engine."""
        self.associations.extend(associations)
        self.cognitive_state.last_update = datetime.now()
        print(f"WorkingMemory: Added {len(associations)} associations")
    
    def add_insight(self, insight: Entry):
        """Add a new insight generated by introspection."""
        self.generated_insights.append(insight)
        self.cognitive_state.active_insights.append(insight.content)
        self.cognitive_state.last_update = datetime.now()
        print(f"WorkingMemory: New insight added - {insight.entry_type.name}")
    
    def add_context_tag(self, tag: str):
        """Add a contextual tag for the current processing."""
        if tag not in self.context_tags:
            self.context_tags.append(tag)
    
    def update_cognitive_state(self, **kwargs):
        """Update the cognitive state with new information."""
        for key, value in kwargs.items():
            if hasattr(self.cognitive_state, key):
                setattr(self.cognitive_state, key, value)
        self.cognitive_state.last_update = datetime.now()
    
    def set_emotional_state(self, emotional_state: EmotionalState):
        """Set the current emotional state."""
        self.cognitive_state.emotional_state = emotional_state
        self.cognitive_state.emotional_processing_enabled = True
        self.cognitive_state.last_update = datetime.now()
        print(f"WorkingMemory: Emotional state set - {emotional_state.to_summary_string()}")
    
    def get_emotional_context(self) -> Dict[str, Any]:
        """Get emotional context for processing."""
        if not self.cognitive_state.emotional_state:
            return {}
        
        return {
            "emotional_quadrant": self.cognitive_state.emotional_state.get_emotional_quadrant(),
            "dominant_emotion": self.cognitive_state.emotional_state.get_dominant_emotion(),
            "emotional_intensity": self.cognitive_state.emotional_state.get_emotional_intensity(),
            "is_positive": self.cognitive_state.emotional_state.is_positive(),
            "is_high_arousal": self.cognitive_state.emotional_state.is_high_arousal(),
            "valence": self.cognitive_state.emotional_state.valence,
            "arousal": self.cognitive_state.emotional_state.arousal
        }
    
    def set_context_data(self, key: str, data: Any):
        """Set processor-specific context data."""
        self.context_data[key] = data
        self.cognitive_state.last_update = datetime.now()
    
    def get_context_data(self, key: str, default: Any = None) -> Any:
        """Get processor-specific context data."""
        return self.context_data.get(key, default)
    
    def get_structured_input(self) -> Optional[StructuredInput]:
        """Get the current structured input."""
        return self.structured_input
    
    def get_retrieved_memories(self) -> List[Entry]:
        """Get retrieved memories."""
        return self.retrieved_memories
    
    def get_generated_insights(self) -> List[Entry]:
        """Get generated insights."""
        return self.generated_insights
    
    def get_context_summary(self) -> str:
        """Get a summary of the current context for processing."""
        summary_parts = []
        
        if self.structured_input:
            summary_parts.append(f"Input: {self.structured_input.raw_text}")
            summary_parts.append(f"Intent: {self.structured_input.intent}")
            summary_parts.append(f"Sentiment: {self.structured_input.sentiment}")
        
        if self.retrieved_memories:
            summary_parts.append(f"Retrieved {len(self.retrieved_memories)} relevant memories")
        
        if self.generated_insights:
            summary_parts.append(f"Generated {len(self.generated_insights)} insights")
        
        if self.context_tags:
            summary_parts.append(f"Context tags: {', '.join(self.context_tags)}")
        
        return " | ".join(summary_parts)
    
    def is_ready_for_response(self) -> bool:
        """Check if the working memory has enough information for response generation."""
        return (
            self.structured_input is not None and
            (len(self.retrieved_memories) > 0 or len(self.generated_insights) > 0) and
            self.cognitive_state.cycle_count >= 1
        )
    
    def get_all_content(self) -> Dict[str, Any]:
        """Get all content in working memory for response generation."""
        return {
            "input": self.structured_input,
            "memories": self.retrieved_memories,
            "insights": self.generated_insights,
            "associations": self.associations,
            "context_tags": self.context_tags,
            "cognitive_state": self.cognitive_state
        }